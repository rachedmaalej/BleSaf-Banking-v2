{
  "permissions": {
    "allow": [
      "Bash(wc:*)",
      "Bash(pnpm --filter @blesaf/api exec prisma db push:*)",
      "Bash(pnpm db:seed:*)",
      "Bash(pnpm dev:api:*)",
      "Bash(pnpm dev:web:*)",
      "Bash(python3:*)",
      "Bash(node:*)",
      "Bash(netstat:*)",
      "Bash(taskkill:*)",
      "Bash(pnpm --filter @blesaf/web exec tsc:*)",
      "Bash(npx prisma db execute:*)",
      "Bash(pnpm --filter @blesaf/shared build:*)",
      "Bash(npx tsc:*)",
      "Bash(findstr:*)",
      "Bash(powershell -Command:*)",
      "Bash(pnpm dev:*)",
      "Bash(timeout:*)",
      "WebFetch(domain:nemo-q.com)",
      "WebFetch(domain:www.nngroup.com)",
      "Bash(copy \"c:\\\\Users\\\\rache\\\\CCProjects\\\\BléSaf - Banking\\\\docs\\\\Design\\\\uib-logo.jpg\" \"c:\\\\Users\\\\rache\\\\CCProjects\\\\BléSaf - Banking\\\\apps\\\\web\\\\public\\\\uib-logo.jpg\")",
      "Bash(pnpm run build:*)",
      "Bash(git init:*)",
      "Bash(git add:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nv0.2.0 - Simplified teller workflow and global queue sync\n\n## Queue Management Improvements\n\n### Simplified Teller Workflow\n- Removed \"Start Service\" button from TellerDashboard\n- Tickets now go directly from WAITING → SERVING when called\n- Reduced teller clicks from 3 to 2 \\(Call → Complete/No-Show\\)\n- Service timer starts immediately when customer is called\n- SMS notification still sent with \"your turn\" semantics\n\n### Global FIFO Queue Sync\n- Added globalQueue field to TellerQueueView interface\n- All teller screens now show the same FIFO queue in footer\n- Queue updates in real-time when any teller calls a customer\n- Fixed optimistic updates to properly remove called tickets from globalQueue\n- Added totalWaitingInBranch counter for accurate queue counts\n\n### Queue Order Consistency\n- Fixed TV Display to use backend-sorted waitingTickets \\(by priority, then createdAt\\)\n- Removed incorrect alphabetical sorting by ticket number\n- Ensured teller footer matches TV Display queue order\n\n### Responsive Design\n- Made TellerDashboard fully responsive with Tailwind breakpoints\n- Footer shows 3 tickets on mobile, 6 on larger screens\n- Proper grid layouts for different screen sizes\n\n## Files Modified\n- packages/shared/src/types.ts - Added globalQueue and totalWaitingInBranch types\n- apps/api/src/services/queueService.ts - Added debug logging for global queue\n- apps/web/src/stores/queueStore.ts - Fixed optimistic updates for globalQueue\n- apps/web/src/pages/teller/TellerDashboard.tsx - Responsive layout, global queue footer\n- apps/web/src/pages/display/QueueDisplay.tsx - Fixed queue sorting\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git commit:*)",
      "Bash(gh repo create:*)",
      "Bash(where:*)",
      "Bash(git remote:*)",
      "Bash(git branch:*)",
      "Bash(git push:*)",
      "WebFetch(domain:www.societegenerale.com)",
      "WebFetch(domain:www.brandcolorcode.com)",
      "Bash(tasklist:*)",
      "Bash(wsl:*)",
      "Bash(docker info:*)",
      "Bash(npx prisma db seed)",
      "Bash(npx tsx:*)",
      "Bash(ping:*)",
      "Bash(npx dotenv:*)",
      "Bash(pnpm tsx:*)",
      "Bash(TOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJhMWI2N2NiNS1iYmM5LTQ3MGMtOGJhMi0wZTc2NzkwZTA2ZDIiLCJ0ZW5hbnRJZCI6IjcxNTc1MWJhLTlkZjUtNDRhNS04Mjc2LTQ1Y2EwYTI1YjE5YyIsImJyYW5jaElkIjoiNDEzODE5NmMtMWM3MC00MjgyLTgxYTItN2ZhYTRhNWVjM2UxIiwicm9sZSI6ImJyYW5jaF9tYW5hZ2VyIiwiaWF0IjoxNzcwMDM4MjQxLCJleHAiOjE3NzAwMzkxNDF9.WWAQNxFIxCJWWr7dCQfAdLpazlPN2kOrI-yxiRjPTBc\")",
      "Bash(pnpm tsc:*)",
      "Bash(npx prisma:*)",
      "Bash(dir:*)",
      "Bash(npx kill-port:*)",
      "Bash(find:*)",
      "Bash(pnpm db:push:*)",
      "Bash(pnpm add:*)",
      "Bash(pnpm typecheck:*)",
      "Bash(pnpm exec tsc:*)",
      "Bash(pnpm db:generate:*)",
      "Bash(pnpm store prune:*)",
      "Bash(pnpm install:*)",
      "Bash(pnpm build:*)",
      "Bash(more:*)",
      "Bash(TOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJhMWI2N2NiNS1iYmM5LTQ3MGMtOGJhMi0wZTc2NzkwZTA2ZDIiLCJ0ZW5hbnRJZCI6IjcxNTc1MWJhLTlkZjUtNDRhNS04Mjc2LTQ1Y2EwYTI1YjE5YyIsImJyYW5jaElkIjoiNDEzODE5NmMtMWM3MC00MjgyLTgxYTItN2ZhYTRhNWVjM2UxIiwicm9sZSI6ImJyYW5jaF9tYW5hZ2VyIiwiaWF0IjoxNzcwMjI4MjA4LCJleHAiOjE3NzAyMjkxMDh9.r1OVWoPH5vufodY-Myhzkne2exmpGYejCC_Ryjqm5i0\")",
      "Bash(TOKEN=\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJhMWI2N2NiNS1iYmM5LTQ3MGMtOGJhMi0wZTc2NzkwZTA2ZDIiLCJ0ZW5hbnRJZCI6IjcxNTc1MWJhLTlkZjUtNDRhNS04Mjc2LTQ1Y2EwYTI1YjE5YyIsImJyYW5jaElkIjoiNDEzODE5NmMtMWM3MC00MjgyLTgxYTItN2ZhYTRhNWVjM2UxIiwicm9sZSI6ImJyYW5jaF9tYW5hZ2VyIiwiaWF0IjoxNzcwMjI4MjkyLCJleHAiOjE3NzAyMjkxOTJ9.7zDnIkk3I98ass9n3bKyNxbf-m_MCcEqwmy58u39u0I\")",
      "Bash(jq:*)",
      "Bash(docker start:*)",
      "Bash(docker ps:*)",
      "Bash(docker:*)",
      "Bash(\"c:\\\\Users\\\\rache\\\\CCProjects\\\\BléSaf - Banking\\\\apps\\\\api\\\\src\\\\services\\\\metricsService.ts\" << 'ENDOFFILE'\nimport { prisma } from '../lib/prisma';\nimport { getTodayRangeUTC, calculateDurationMins } from '../lib/datetime';\nimport { NotFoundError, ForbiddenError } from '../lib/errors';\nimport { getRedisClient } from '../lib/redis';\nimport { JWTPayload, USER_ROLE, TICKET_STATUS } from '@blesaf/shared';\nimport type { CompositeMetrics, SlaTrajectory, RecommendationSummary } from '@blesaf/shared';\n\nconst CACHE_TTL = 60; // 60 seconds\n\nexport const metricsService = {\n  /**\n   * Get composite metrics for the branch manager hero bar\n   * Combines queue health score, capacity utilization, SLA trajectory\n   */\n  async getCompositeMetrics\\(\n    branchId: string,\n    tenantId: string,\n    user: JWTPayload\n  \\): Promise<CompositeMetrics> {\n    const branch = await prisma.branch.findUnique\\({\n      where: { id: branchId },\n      select: { tenantId: true, timezone: true },\n    }\\);\n\n    if \\(!branch || branch.tenantId !== tenantId\\) {\n      throw new NotFoundError\\('Branch not found'\\);\n    }\n\n    if \\(user.role === USER_ROLE.BRANCH_MANAGER && user.branchId !== branchId\\) {\n      throw new ForbiddenError\\('Cannot access metrics for another branch'\\);\n    }\n\n    // Check Redis cache\n    const redis = getRedisClient\\(\\);\n    const cacheKey = `metrics:composite:${branchId}`;\n    const cached = await redis.get\\(cacheKey\\);\n    if \\(cached\\) {\n      return JSON.parse\\(cached\\);\n    }\n\n    const { start, end } = getTodayRangeUTC\\(branch.timezone\\);\n\n    // Parallel queries for all data we need\n    const [\n      waitingCount,\n      completedTickets,\n      counters,\n      branchTarget,\n      // Get tickets completed in last 2 hours for SLA trajectory\n      recentTickets,\n      olderTickets,\n    ] = await Promise.all\\([\n      // Current waiting count\n      prisma.ticket.count\\({\n        where: { branchId, status: TICKET_STATUS.WAITING, createdAt: { gte: start, lte: end } },\n      }\\),\n      // All completed tickets today \\(for SLA\\)\n      prisma.ticket.findMany\\({\n        where: {\n          branchId,\n          status: TICKET_STATUS.COMPLETED,\n          calledAt: { not: null },\n          createdAt: { gte: start, lte: end },\n        },\n        select: { createdAt: true, calledAt: true, completedAt: true },\n      }\\),\n      // All counters\n      prisma.counter.findMany\\({\n        where: { branchId },\n        select: { status: true, id: true },\n      }\\),\n      // Branch target for SLA threshold\n      prisma.branchTarget.findFirst\\({\n        where: { branchId },\n        orderBy: { date: 'desc' },\n      }\\),\n      // Tickets completed in last 1 hour \\(recent SLA\\)\n      prisma.ticket.findMany\\({\n        where: {\n          branchId,\n          status: TICKET_STATUS.COMPLETED,\n          calledAt: { not: null },\n          completedAt: { gte: new Date\\(Date.now\\(\\) - 60 * 60 * 1000\\) },\n        },\n        select: { createdAt: true, calledAt: true },\n      }\\),\n      // Tickets completed 1-2 hours ago \\(older SLA for trajectory\\)\n      prisma.ticket.findMany\\({\n        where: {\n          branchId,\n          status: TICKET_STATUS.COMPLETED,\n          calledAt: { not: null },\n          completedAt: {\n            gte: new Date\\(Date.now\\(\\) - 2 * 60 * 60 * 1000\\),\n            lt: new Date\\(Date.now\\(\\) - 60 * 60 * 1000\\),\n          },\n        },\n        select: { createdAt: true, calledAt: true },\n      }\\),\n    ]\\);\n\n    const slaThreshold = branchTarget?.slaThreshold ?? 15;\n    const totalCounters = counters.length;\n    const openCounters = counters.filter\\(\\(c\\) => c.status === 'open'\\).length;\n    const onBreakCounters = counters.filter\\(\\(c\\) => c.status === 'on_break'\\).length;\n\n    // --- Queue Health Score \\(0-100\\) ---\n    // 35% wait time ratio + 25% SLA + 20% capacity + 20% queue pressure\n    const waitTimes = completedTickets.map\\(\\(t\\) => calculateDurationMins\\(t.createdAt, t.calledAt!\\)\\);\n    const avgWaitMins = waitTimes.length > 0\n      ? waitTimes.reduce\\(\\(a, b\\) => a + b, 0\\) / waitTimes.length\n      : 0;\n\n    const withinSla = waitTimes.filter\\(\\(w\\) => w <= slaThreshold\\).length;\n    const slaPercent = waitTimes.length > 0 ? \\(withinSla / waitTimes.length\\) * 100 : 100;\n\n    const queueCritical = 20; // critical threshold for waiting count\n    const neededCounters = Math.max\\(1, Math.ceil\\(waitingCount / 5\\)\\); // rough: 1 counter per 5 waiting\n\n    const waitScore = Math.max\\(0, 1 - Math.min\\(avgWaitMins / slaThreshold, 2\\)\\);\n    const slaScore = slaPercent / 100;\n    const capacityScore = Math.min\\(openCounters / Math.max\\(neededCounters, 1\\), 1\\);\n    const pressureScore = Math.max\\(0, 1 - Math.min\\(waitingCount / queueCritical, 1\\)\\);\n\n    const healthScore = Math.round\\(\n      \\(0.35 * waitScore + 0.25 * slaScore + 0.20 * capacityScore + 0.20 * pressureScore\\) * 100\n    \\);\n\n    const healthLabel = healthScore >= 80 ? 'excellent'\n      : healthScore >= 60 ? 'good'\n      : healthScore >= 30 ? 'attention'\n      : 'critical';\n\n    // --- Capacity Utilization ---\n    const effectiveCounters = openCounters - onBreakCounters;\n    const utilization = neededCounters > 0\n      ? Math.round\\(\\(effectiveCounters / neededCounters\\) * 100\\)\n      : effectiveCounters > 0 ? 100 : 0;\n\n    const capacityLabel = utilization > 150 ? 'overstaffed'\n      : utilization >= 80 ? 'adequate'\n      : utilization >= 50 ? 'understaffed'\n      : 'critical';\n\n    // --- SLA Trajectory ---\n    const recentSla = calculateSlaPercent\\(recentTickets, slaThreshold\\);\n    const olderSla = calculateSlaPercent\\(olderTickets, slaThreshold\\);\n\n    let slaTrajectory: SlaTrajectory = 'on_track';\n    const slaProjected = recentTickets.length >= 2\n      ? Math.max\\(0, Math.min\\(100, Math.round\\(recentSla + \\(recentSla - olderSla\\) * 0.5\\)\\)\\)\n      : Math.round\\(slaPercent\\);\n\n    if \\(slaProjected < 70\\) {\n      slaTrajectory = 'failing';\n    } else if \\(slaProjected < 85 || \\(recentSla < olderSla - 5\\)\\) {\n      slaTrajectory = 'at_risk';\n    }\n\n    const metrics: CompositeMetrics = {\n      healthScore,\n      healthLabel,\n      capacityUtilization: utilization,\n      capacityLabel,\n      slaTrajectory,\n      slaCurrent: Math.round\\(slaPercent\\),\n      slaProjected,\n      nextAction: null, // Will be populated by recommendation engine\n      generatedAt: new Date\\(\\).toISOString\\(\\),\n    };\n\n    // Cache result\n    await redis.setex\\(cacheKey, CACHE_TTL, JSON.stringify\\(metrics\\)\\);\n\n    return metrics;\n  },\n};\n\nfunction calculateSlaPercent\\(\n  tickets: { createdAt: Date; calledAt: Date | null }[],\n  threshold: number\n\\): number {\n  if \\(tickets.length === 0\\) return 100;\n  const withinSla = tickets.filter\\(\\(t\\) => {\n    if \\(!t.calledAt\\) return true;\n    return calculateDurationMins\\(t.createdAt, t.calledAt\\) <= threshold;\n  }\\).length;\n  return Math.round\\(\\(withinSla / tickets.length\\) * 100\\);\n}\nENDOFFILE)",
      "Bash(npx vite build:*)",
      "Bash(ls:*)"
    ]
  }
}
