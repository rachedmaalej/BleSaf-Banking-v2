generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================
// TENANT (Bank)
// ============================================================

model Tenant {
  id             String   @id @default(uuid())
  name           String
  subdomain      String   @unique
  logoUrl        String?
  primaryColor   String?
  languageConfig Json     @default("{\"default\":\"fr\",\"available\":[\"fr\",\"ar\"]}")
  status         String   @default("active") // active | suspended | inactive
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  branches Branch[]
  users    User[]

  @@index([subdomain])
}

// ============================================================
// BRANCH
// ============================================================

model Branch {
  id               String   @id @default(uuid())
  tenantId         String
  tenant           Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  name             String
  code             String
  address          String?
  region           String?
  timezone         String   @default("Africa/Tunis")
  notifyAtPosition Int      @default(2) // Notify when X patients away
  status           String   @default("active") // active | inactive
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  counters      Counter[]
  services      ServiceCategory[]
  tickets       Ticket[]
  users         User[]
  dailyStats    DailyBranchStats[]
  hourlyStats   HourlySnapshot[]

  @@unique([tenantId, code])
  @@index([tenantId])
}

// ============================================================
// COUNTER (Guichet)
// ============================================================

model Counter {
  id              String   @id @default(uuid())
  branchId        String
  branch          Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  number          Int
  label           String?
  status          String   @default("closed") // open | closed | on_break
  currentTicketId String?  @unique
  assignedUserId  String?
  assignedUser    User?    @relation("AssignedCounter", fields: [assignedUserId], references: [id])
  activeBreakId   String?  @unique
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  assignedServices CounterService[]
  tickets          Ticket[]         @relation("ServedAtCounter")
  currentTicket    Ticket?          @relation("CurrentTicket", fields: [currentTicketId], references: [id])
  breaks           TellerBreak[]    @relation("CounterBreaks")
  activeBreak      TellerBreak?     @relation("ActiveBreak", fields: [activeBreakId], references: [id])

  @@unique([branchId, number])
  @@index([branchId])
  @@index([status])
}

// ============================================================
// SERVICE CATEGORY
// ============================================================

model ServiceCategory {
  id                      String   @id @default(uuid())
  branchId                String
  branch                  Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  nameAr                  String
  nameFr                  String
  prefix                  String   // A, B, C... for ticket numbering
  icon                    String?
  priorityWeight          Int      @default(1)
  avgServiceTime          Int      @default(10) // minutes (manual setting)
  useAutomaticServiceTime Boolean  @default(false) // auto-calculate from last 24h
  isActive                Boolean  @default(true)
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt

  counters CounterService[]
  tickets  Ticket[]

  @@unique([branchId, prefix])
  @@index([branchId])
}

// ============================================================
// COUNTER-SERVICE JOIN TABLE
// ============================================================

model CounterService {
  counterId String
  counter   Counter         @relation(fields: [counterId], references: [id], onDelete: Cascade)
  serviceId String
  service   ServiceCategory @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@id([counterId, serviceId])
  @@index([serviceId])
}

// ============================================================
// TICKET
// ============================================================

model Ticket {
  id                  String   @id @default(uuid())
  branchId            String
  branch              Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  serviceCategoryId   String
  serviceCategory     ServiceCategory @relation(fields: [serviceCategoryId], references: [id])
  ticketNumber        String   // "A-042"
  status              String   @default("waiting") // waiting | called | serving | completed | no_show | cancelled
  priority            String   @default("normal") // normal | vip
  customerPhone       String?
  notificationChannel String?  // none | sms | whatsapp
  checkinMethod       String   @default("kiosk") // kiosk | mobile | manual
  counterId           String?
  counter             Counter? @relation("ServedAtCounter", fields: [counterId], references: [id])
  servedByUserId      String?
  servedBy            User?    @relation("ServedTickets", fields: [servedByUserId], references: [id])
  calledAt            DateTime?
  servingStartedAt    DateTime?
  completedAt         DateTime?
  notes               String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relation for counter's current ticket
  currentAtCounter Counter? @relation("CurrentTicket")

  // Audit and notifications
  history       TicketHistory[]
  notifications NotificationLog[]

  @@index([branchId, status])
  @@index([branchId, createdAt])
  @@index([serviceCategoryId, status])
  @@index([servedByUserId])
}

// ============================================================
// USER
// ============================================================

model User {
  id           String   @id @default(uuid())
  tenantId     String
  tenant       Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  branchId     String?
  branch       Branch?  @relation(fields: [branchId], references: [id])
  name         String
  email        String   @unique
  passwordHash String
  role         String   // super_admin | bank_admin | branch_manager | teller
  status       String   @default("active") // active | inactive
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  servedTickets   Ticket[]       @relation("ServedTickets")
  assignedCounter Counter[]      @relation("AssignedCounter")
  refreshTokens   RefreshToken[]
  ticketHistory   TicketHistory[]
  breaks          TellerBreak[]  @relation("UserBreaks")
  breaksStarted   TellerBreak[]  @relation("BreakStarter")
  breaksEnded     TellerBreak[]  @relation("BreakEnder")

  @@index([tenantId])
  @@index([branchId])
  @@index([email])
}

// ============================================================
// REFRESH TOKEN (Stateful Auth)
// ============================================================

model RefreshToken {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token      String   @unique
  deviceInfo String?
  expiresAt  DateTime
  createdAt  DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// ============================================================
// TICKET HISTORY (Audit Log)
// ============================================================

model TicketHistory {
  id        String   @id @default(uuid())
  ticketId  String
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  action    String   // created | called | serving | completed | no_show | cancelled | transferred
  actorId   String?  // userId who performed action (null for system actions)
  actor     User?    @relation(fields: [actorId], references: [id])
  metadata  Json?    // additional context (e.g., transfer destination, counter info)
  createdAt DateTime @default(now())

  @@index([ticketId])
  @@index([actorId])
  @@index([createdAt])
}

// ============================================================
// NOTIFICATION LOG
// ============================================================

model NotificationLog {
  id          String   @id @default(uuid())
  ticketId    String
  ticket      Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  channel     String   // sms | whatsapp
  messageType String   // confirmation | almost_turn | your_turn
  recipient   String   // phone number
  providerId  String?  // Twilio message SID
  status      String   // queued | sent | delivered | failed
  cost        Decimal? @db.Decimal(10, 4)
  errorMsg    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([ticketId])
  @@index([status])
  @@index([createdAt])
}

// ============================================================
// DAILY BRANCH STATS (Pre-computed)
// ============================================================

model DailyBranchStats {
  id                 String   @id @default(uuid())
  branchId           String
  branch             Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  date               DateTime @db.Date
  totalTickets       Int      @default(0)
  completedTickets   Int      @default(0)
  noShows            Int      @default(0)
  avgWaitTimeMins    Int?
  avgServiceTimeMins Int?
  peakHour           Int?     // 0-23
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  @@unique([branchId, date])
  @@index([branchId])
  @@index([date])
}

// ============================================================
// HOURLY SNAPSHOT (For analytics)
// ============================================================

model HourlySnapshot {
  id              String   @id @default(uuid())
  branchId        String
  branch          Branch   @relation(fields: [branchId], references: [id], onDelete: Cascade)
  timestamp       DateTime
  hour            Int      // 0-23
  queueLength     Int      @default(0)
  activeCounters  Int      @default(0)
  avgWaitTimeMins Int?
  createdAt       DateTime @default(now())

  @@index([branchId, timestamp])
  @@index([branchId, hour])
}

// ============================================================
// TELLER BREAK (Pause Tracking)
// ============================================================

model TellerBreak {
  id           String    @id @default(uuid())
  counterId    String
  counter      Counter   @relation("CounterBreaks", fields: [counterId], references: [id], onDelete: Cascade)
  userId       String
  user         User      @relation("UserBreaks", fields: [userId], references: [id])
  branchId     String

  reason       String    // lunch | prayer | personal | urgent
  durationMins Int       // planned duration in minutes
  startedAt    DateTime  @default(now())
  expectedEnd  DateTime  // calculated: startedAt + durationMins
  actualEnd    DateTime? // null until break ends

  startedById  String    // userId who initiated (BM or self)
  startedBy    User      @relation("BreakStarter", fields: [startedById], references: [id])
  endedById    String?   // userId who ended break
  endedBy      User?     @relation("BreakEnder", fields: [endedById], references: [id])

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relation for active break
  activeAtCounter Counter? @relation("ActiveBreak")

  @@index([counterId])
  @@index([branchId, startedAt])
  @@index([userId])
}
